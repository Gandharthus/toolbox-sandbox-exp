# models_search.py
from __future__ import annotations

from datetime import date, datetime
from typing import Any, Literal, TypeAlias

from pydantic import BaseModel, Field, ConfigDict


# -----------------------------------------------------------------------------
# Shared scalar type
# -----------------------------------------------------------------------------

JsonScalar = str | int | float | bool | date | datetime


# -----------------------------------------------------------------------------
# Leaf query bodies
# -----------------------------------------------------------------------------

class MatchFieldOptions(BaseModel):
    """
    Options for a single field in a `match` query.

    LLM guidance:
      - Use when you need per-field controls like `operator` or `fuzziness`.
      - Example shape: {"match": {"<field>": {"query": "...", "operator": "and"}}}
    """
    query: JsonScalar = Field(..., description="Analyzed input to match against this field.")
    operator: Literal["and", "or"] | None = Field(
        None, description="Logical operator between analyzed terms."
    )
    minimum_should_match: int | str | None = Field(
        None, description='Minimum number/percent of terms required, e.g. 2 or "75%".'
    )
    fuzziness: int | Literal["AUTO"] | None = Field(
        None, description='Allowed edit distance; e.g. "AUTO", 1, 2.'
    )
    prefix_length: int | None = Field(
        None, description="Number of initial characters exempt from fuzziness."
    )
    max_expansions: int | None = Field(
        None, description="Upper bound on term variations generated by fuzziness."
    )
    analyzer: str | None = Field(None, description="Override analyzer for this query.")
    boost: float | None = Field(None, description="Score multiplier for this clause.")

    model_config = ConfigDict(extra="forbid")


class TermValue(BaseModel):
    """
    Verbose object form for a `term` query value (when you need a boost).

    LLM guidance:
      - Compact: {"term": {"status": "active"}}
      - Verbose: {"term": {"status": {"value": "active", "boost": 2.0}}}
    """
    value: JsonScalar = Field(..., description="Exact (non-analyzed) value to match.")
    boost: float | None = Field(None, description="Score multiplier for this term.")
    model_config = ConfigDict(extra="forbid")


class RangeOps(BaseModel):
    """
    Range operators for a single field in a `range` query.

    LLM guidance:
      - Use ISO datetimes or date math (e.g., 'now-7d/d') for time fields.
      - Example: {"range": {"@timestamp": {"gte": "now-7d/d", "lt": "now/d"}}}
    """
    gte: JsonScalar | None = Field(None, description="Greater than or equal.")
    gt: JsonScalar | None = Field(None, description="Greater than (strict).")
    lte: JsonScalar | None = Field(None, description="Less than or equal.")
    lt: JsonScalar | None = Field(None, description="Less than (strict).")
    format: str | None = Field(None, description="Date format string for parsing inputs.")
    time_zone: str | None = Field(None, description="Time zone used when parsing dates.")
    boost: float | None = Field(None, description="Score multiplier for this range.")
    model_config = ConfigDict(extra="forbid")


# -----------------------------------------------------------------------------
# Query containers (each is a one-key object matching ES DSL)
# -----------------------------------------------------------------------------

class MatchQuery(BaseModel):
    """
    Container for a `match` query (single-field full-text).

    JSON shape:
      {"match": {"<field>": <text or MatchFieldOptions>}}

    LLM usage:
      - Default choice for full-text search on one field.
      - For multi-field text, prefer `MultiMatchQuery`.
    """
    match: dict[str, JsonScalar | MatchFieldOptions] = Field(
        ..., description="Map of one field name to its match value/options."
    )
    model_config = ConfigDict(extra="forbid")


class MultiMatchQuery(BaseModel):
    """
    Container for a `multi_match` query (full-text across multiple fields).

    JSON shape:
      {"multi_match": {"query": "...", "fields": ["title^2","body"], "type": "best_fields"}}

    LLM usage:
      - Use for multi-field text; boost via '^' (e.g., 'title^2').
      - `type`: best_fields | most_fields | cross_fields | phrase | phrase_prefix.
    """
    multi_match: dict[str, Any] = Field(
        ..., description="Options for the multi_match query (query, fields, type, etc.)."
    )
    model_config = ConfigDict(extra="forbid")

    @classmethod
    def build(
        cls,
        query: str,
        fields: list[str],
        type: Literal["best_fields", "most_fields", "cross_fields", "phrase", "phrase_prefix"] | None = None,
        tie_breaker: float | None = None,
        operator: Literal["and", "or"] | None = None,
        minimum_should_match: int | str | None = None,
        boost: float | None = None,
        **kwargs: Any,
    ) -> MultiMatchQuery:
        """Convenience builder that sets only provided keys (keeps JSON clean)."""
        payload: dict[str, Any] = {"query": query, "fields": fields}
        if type is not None:
            payload["type"] = type
        if tie_breaker is not None:
            payload["tie_breaker"] = tie_breaker
        if operator is not None:
            payload["operator"] = operator
        if minimum_should_match is not None:
            payload["minimum_should_match"] = minimum_should_match
        if boost is not None:
            payload["boost"] = boost
        payload.update(kwargs)
        return cls(multi_match=payload)


class TermQuery(BaseModel):
    """
    Container for a `term` query (exact match on a single field).

    JSON shapes:
      Compact: {"term": {"status": "active"}}
      Verbose: {"term": {"status": {"value": "active", "boost": 2.0}}}

    LLM usage:
      - Use for keyword/numeric/boolean/date fields (non-analyzed exact).
    """
    term: dict[str, JsonScalar | TermValue] = Field(
        ..., description="Map of one field name to an exact value or TermValue object."
    )
    model_config = ConfigDict(extra="forbid")


class TermsQuery(BaseModel):
    """
    Container for a `terms` query (IN-list exact match).

    JSON shape:
      {"terms": {"status": ["draft", "published"]}}
    """
    terms: dict[str, list[JsonScalar]] = Field(
        ..., description="Map of one field name to a list of allowed values."
    )
    model_config = ConfigDict(extra="forbid")


class RangeQuery(BaseModel):
    """
    Container for a `range` query.

    JSON shape:
      {"range": {"timestamp": {"gte": "2025-01-01", "lt": "2026-01-01"}}}
    """
    range: dict[str, RangeOps] = Field(
        ..., description="Map of one field name to RangeOps operators."
    )
    model_config = ConfigDict(extra="forbid")


class ExistsQuery(BaseModel):
    """
    Container for an `exists` query (documents where a field is present).

    JSON shape:
      {"exists": {"field": "author"}}
    """
    exists: dict[Literal["field"], str] = Field(
        ..., description='Object with key "field" naming the field that must exist.'
    )
    model_config = ConfigDict(extra="forbid")


class MatchAllQuery(BaseModel):
    """
    Container for a `match_all` query (matches every document).

    JSON shapes:
      {"match_all": {}}
      {"match_all": {"boost": 1.2}}
    """
    match_all: dict[str, Any] = Field(
        default_factory=dict, description="Optional object; may contain 'boost'."
    )
    model_config = ConfigDict(extra="forbid")


class IdsQuery(BaseModel):
    """
    Container for an `ids` query (match by document IDs).

    JSON shape:
      {"ids": {"values": ["1","2","3"]}}
    """
    ids: dict[Literal["values"], list[str]] = Field(
        ..., description='Object with key "values" listing document IDs.'
    )
    model_config = ConfigDict(extra="forbid")


# -----------------------------------------------------------------------------
# Declare the forward-ref union as a STRING TypeAlias (no runtime union math)
# -----------------------------------------------------------------------------

Query: TypeAlias = (
    "MatchQuery | MultiMatchQuery | TermQuery | TermsQuery | "
    "RangeQuery | ExistsQuery | MatchAllQuery | IdsQuery | BoolQuery"
)


# -----------------------------------------------------------------------------
# Recursive bool query (uses the forward-ref "Query")
# -----------------------------------------------------------------------------

class BoolBody(BaseModel):
    """
    Inner body for a `bool` query. Combines other queries using boolean logic.

    LLM guidance:
      - `must`: scoring, documents MUST match all queries here.
      - `filter`: non-scoring (cached) filters; use for constraints (faster).
      - `should`: optional scoring clauses; set `minimum_should_match` if you
                  need at least N/percent of these to match.
      - `must_not`: negate (documents MUST NOT match).
      - You can nest `BoolQuery` inside any of these lists.
    """
    must: list[Query] | None = Field(None, description="All must match; contributes to score.")
    filter: list[Query] | None = Field(None, description="All must match; does NOT affect score.")
    should: list[Query] | None = Field(None, description="Optional; affects score unless minimum_should_match is set.")
    must_not: list[Query] | None = Field(None, description="Documents must NOT match these.")
    minimum_should_match: int | str | None = Field(
        None, description='Minimum number/percent of `should` clauses that must match, e.g. 1 or "75%".'
    )
    boost: float | None = Field(None, description="Score multiplier for the bool query as a whole.")

    model_config = ConfigDict(extra="forbid")


class BoolQuery(BaseModel):
    """
    Container for a `bool` query.

    JSON shape:
      {"bool": {"must": [...], "filter": [...], "should": [...], "must_not": [...], "minimum_should_match": 1}}
    """
    bool: BoolBody = Field(..., description="Boolean composition of other queries.")
    model_config = ConfigDict(extra="forbid")


# Resolve forward refs now that all classes are defined and the alias exists.
BoolBody.model_rebuild()
BoolQuery.model_rebuild()


# -----------------------------------------------------------------------------
# Search request wrapper
# -----------------------------------------------------------------------------

class SearchRequest(BaseModel):
    """
    Minimal wrapper for the Elasticsearch `_search` request body.

    LLM guidance:
      - Set `query` to one of the containers above (match, bool, range, etc.).
      - Use `size` to limit hits; use `from_` (alias 'from') for pagination.
      - Emit JSON using `model_dump(by_alias=True, exclude_none=True)`.
    """
    query: Query = Field(..., description="A single Query DSL container (match, bool, range, etc.).")
    size: int | None = Field(None, description="Maximum number of hits to return.")
    from_: int | None = Field(default=None, alias="from", description="Offset for pagination (use with `size`).")
    model_config = ConfigDict(populate_by_name=True, extra="forbid")


# SearchRequest also references Query; resolve again to be safe.
SearchRequest.model_rebuild()


# -----------------------------------------------------------------------------
# Optional: quick self-test when run directly
# -----------------------------------------------------------------------------

if __name__ == "__main__":
    # Build a realistic query to ensure everything wires up
    q = BoolQuery(
        bool=BoolBody(
            must=[
                MatchQuery(match={"title": MatchFieldOptions(query="wind power", operator="and")})
            ],
            filter=[
                RangeQuery(range={"@timestamp": RangeOps(gte="now-7d/d", lt="now/d")}),
                ExistsQuery(exists={"field": "author"})
            ],
            should=[
                TermQuery(term={"lang": "en"}),
                TermsQuery(terms={"category": ["energy", "climate"]}),
            ],
            minimum_should_match=1,
        )
    )

    req = SearchRequest(query=q, size=25, **{"from": 0})

    print(req.model_dump(by_alias=True, exclude_none=True))
